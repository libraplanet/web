<!DOCTYPE html>
<html>
	<head>
		<meta name="viewport" content="width=device-width,initial-scale=1.0,maximum-scale=1.0,user-scalable=0" />
		<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
		<meta http-equiv="X-UA-Compatible" content="ie=edge">
		<title>babylon.js</title>
		<script src="babylon.js/babylon.max.js"></script> 
		<!-- <script src="babylon.js/babylon.gui.js"></script> -->
		<script src="babylon.js/babylon.gui.min.js"></script> 
		<!-- <script src="babylon.js/babylon.glTFFileLoader.js"></script> -->
		<script src="babylon.js/babylon.glTFFileLoader.min.js"></script> 

		<!-- <script src="babylon.js/babylon.glTFFileLoader.js"></script> -->
		<script src="babylon.js/babylon.glTFFileLoader.min.js"></script> 
		<script type="text/javascript">
			let Contexts = function() {
				let self = this;
				self.canvas = undefined;
				self.engine = undefined;
				self.scene = undefined;
				self.camera = undefined;
			};
			let Gear = function() {
				let self = this;
				/**
				 * member properties.
				 */
				self.meshModels = undefined
				self.meshTextPlaneX = undefined
				self.meshTextPlaneY = undefined
				self.meshTextPlaneZ = undefined

				/**
				 * init()
				 */
				self.init = function(context) {
					let defCameraTgt = new BABYLON.Vector3(0, 0, 0);
					let defCameraPos = new BABYLON.Vector3(8, 5, 8);
					let scene = context.scene;
					scene.useRightHandedSystem = true;

					// camera
					(function() {
						//let camera = new BABYLON.UniversalCamera('camera', new BABYLON.Vector3(0, 5, -10), scene);
						//camera.setTarget(BABYLON.Vector3.Zero());
						// Parameters: alpha, beta, radius, target position, scene
						let camera = context.camera = new BABYLON.ArcRotateCamera("camera", 0, 0, 1, defCameraTgt, scene);
						// Positions the camera overwriting alpha, beta, radius
						camera.setPosition(defCameraPos);
						camera.attachControl(canvas, true);
						camera.lowerRadiusLimit = 1;
						camera.upperRadiusLimit = 1000;
						camera.wheelDeltaPercentage = 0.01;
						camera.pinchdeltapercentage = 0.01;
						self.camera = camera;
					})();

					// light
					(function() {
						let light = new BABYLON.HemisphericLight('light', new BABYLON.Vector3(0, 1, 0), scene);
					})();

					//// sphere
					//(function() {
					//	let sphere = BABYLON.Mesh.CreateSphere('sphere1', 16, 2, scene, false, BABYLON.Mesh.FRONTSIDE);
					//	sphere.position.y = 1;
					//})();

					//// ground 
					//(function() {
					//	 let ground = BABYLON.Mesh.CreateGround('ground1', 6, 6, 2, scene, false);
					//})();

					// Append glTF model to scene.
					(function() {
						//let fname = './babylon.js/BoomBox.glb';
						//let fname = './babylon.js/Buggy.glb';
						let fname = './babylon.js/Duck.gltf';
						//BABYLON.SceneLoader.Append('./babylon.js/', 'BoomBox.glb', scene, function (scene) {
						BABYLON.SceneLoader.ImportMesh('', fname, null, scene, function (meshes) {
							self.meshModels = meshes;
						});
					})();

					//lines
					(function() {
						let drawLine = function (name, points, color) {
							let meshLine = BABYLON.Mesh.CreateLines(name, points, scene, true);
							meshLine.color = color;
						};
						let color = new BABYLON.Color3(0.4, 0.4, 0.4);
						let len = 10;

						// Y面
						for(let i = 0; i < 10; i++) {
							v = i + 1;
							//X軸
							drawLine('line', [new BABYLON.Vector3(len, 0,    v), new BABYLON.Vector3(-len, 0,    v)], color);
							drawLine('line', [new BABYLON.Vector3(len, 0,   -v), new BABYLON.Vector3(-len, 0,   -v)], color);
							//Z軸
							drawLine('line', [new BABYLON.Vector3(  v, 0,  len), new BABYLON.Vector3(   v, 0, -len)], color);
							drawLine('line', [new BABYLON.Vector3( -v, 0,  len), new BABYLON.Vector3(  -v, 0, -len)], color);
						}

						//中心軸
						(function() {
							let createTextPlaneMesh = function(text, color, size) {
								let dynamicTexture, plane;
								dynamicTexture = new BABYLON.DynamicTexture('DynamicTexture', 50, scene, true);
								dynamicTexture.hasAlpha = true;
								dynamicTexture.drawText(text, 5, 40, 'bold 36px Arial', color , 'transparent', true);
								plane = new BABYLON.Mesh.CreatePlane('TextPlane', size, scene, true);
								plane.material = new BABYLON.StandardMaterial('TextPlaneMaterial', scene);
								plane.material.backFaceCulling = false;
								plane.material.specularColor = new BABYLON.Color3(0, 0, 0);
								plane.material.diffuseTexture = dynamicTexture;
								return plane;
							};
							drawLine('line', [new BABYLON.Vector3(0, 0, 0), new BABYLON.Vector3( len,    0,    0)], new BABYLON.Color3(  1, 0.2, 0.2));
							drawLine('line', [new BABYLON.Vector3(0, 0, 0), new BABYLON.Vector3(   0,  len,    0)], new BABYLON.Color3(0.2,   1, 0.2));
							drawLine('line', [new BABYLON.Vector3(0, 0, 0), new BABYLON.Vector3(   0,    0,  len)], new BABYLON.Color3(0.2, 0.2,   1));
							drawLine('line', [new BABYLON.Vector3(0, 0, 0), new BABYLON.Vector3(-len,    0,    0)], color);
							drawLine('line', [new BABYLON.Vector3(0, 0, 0), new BABYLON.Vector3(   0, -len,    0)], color);
							drawLine('line', [new BABYLON.Vector3(0, 0, 0), new BABYLON.Vector3(   0,    0, -len)], color);

							self.meshTextPlaneX = createTextPlaneMesh('X', '#FF3333', 1.0);
							self.meshTextPlaneY = createTextPlaneMesh('Y', '#33FF33', 1.0);
							self.meshTextPlaneZ = createTextPlaneMesh('Z', '#3333FF', 1.0);
							self.meshTextPlaneX.position = new BABYLON.Vector3( len,    0,    0);
							self.meshTextPlaneY.position = new BABYLON.Vector3(   0,  len,    0);
							self.meshTextPlaneZ.position = new BABYLON.Vector3(   0,    0,  len);
						})();
					})();


					// helper
					(function() {
						let helper = scene.createDefaultEnvironment();
						helper.setMainColor(new BABYLON.Color3(0.75, 0.75, 0.75));
					})();

					// option
					(function() {
						let optimizer, options;
						options = new BABYLON.SceneOptimizerOptions();
						options .targetFrameRate = 20;
						optimizer = new BABYLON.SceneOptimizer(scene, options);
					})();

					// ui
					(function() {
						let advancedTexture = BABYLON.GUI.AdvancedDynamicTexture.CreateFullscreenUI("UI");
						let panel = new BABYLON.GUI.StackPanel();
						let resetCamera = function() {
							self.camera.setTarget(defCameraTgt);
							self.camera.setPosition(defCameraPos);
						};
						let reloadModel = function(url) {
							if(self.meshModels) {
								Array.prototype.forEach.call(self.meshModels, function(mesh) {
									scene.removeMesh(mesh);
								});
								self.meshModels = undefined;
							}
							BABYLON.SceneLoader.ImportMesh('', url, null, scene, function (meshes) {
								//resetCamera();
								self.meshModels = meshes;
							});
						};
						(function() {
							panel.width = "220px";
							panel.fontSize = "12px";
							panel.horizontalAlignment = BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_RIGHT;
							panel.verticalAlignment = BABYLON.GUI.Control.VERTICAL_ALIGNMENT_BOTTOM;
						})();
						(function() {
							let button = BABYLON.GUI.Button.CreateSimpleButton("button1", "camera reset");
							button.paddingTop = "5px";
							button.paddingBottom = "5px";
							button.width = "160px";
							button.height = "35px";
							button.color = "white";
							button.background = "blue";
							button.onPointerDownObservable.add(function(){
								resetCamera();
							});
							panel.addControl(button);
						})();
						(function() {
							let button = BABYLON.GUI.Button.CreateSimpleButton("button2", "(NG) model BoomBox.glb");
							button.paddingTop = "5px";
							button.paddingBottom = "5px";
							button.width = "160px";
							button.height = "35px";
							button.color = "white";
							button.background = "red";
							button.onPointerDownObservable.add(function(){
								reloadModel('./babylon.js/BoomBox.glb');
							});
							panel.addControl(button);
						})();
						(function() {
							let button = BABYLON.GUI.Button.CreateSimpleButton("button3", "(NG) model Buggy.glb");
							button.paddingTop = "5px";
							button.paddingBottom = "5px";
							button.width = "160px";
							button.height = "35px";
							button.color = "white";
							button.background = "red";
							button.onPointerDownObservable.add(function(){
								reloadModel('./babylon.js/Buggy.glb');
							});
							panel.addControl(button);
						})();
						(function() {
							let button = BABYLON.GUI.Button.CreateSimpleButton("button4", "(NG) model Duck.glt");
							button.paddingTop = "5px";
							button.paddingBottom = "5px";
							button.width = "160px";
							button.height = "35px";
							button.color = "white";
							button.background = "red";
							button.onPointerDownObservable.add(function(){
								reloadModel('./babylon.js/Duck.gltf');
							});
							panel.addControl(button);
						})();
						advancedTexture.addControl(panel);
					})();

				};

				/**
				 * update
				 */
				self.update = function(context) {
					let scene = context.scene;
					// Animations
					(function() {
						//billbording
						(function() {
							//let camMat = camera.getViewMatrix();
							let camMat = self.camera.getWorldMatrix();
							if(camMat) {
								let iMat = BABYLON.Matrix.Identity();
								let revMat = camMat.multiply(iMat);
								let revQuat = BABYLON.Quaternion.FromRotationMatrix(revMat);
								self.meshTextPlaneX.rotationQuaternion = revQuat;
								self.meshTextPlaneY.rotationQuaternion = revQuat;
								self.meshTextPlaneZ.rotationQuaternion = revQuat;
							}
						})();
					})();
				};

				/**
				 * render
				 */
				self.render = function(contexts) {
					contexts.scene.render();
				};
			};

			window.onload = function() {
				let contexts = new Contexts();
				let gear = new Gear();

				(function() {
					let canvas = contexts.canvas = document.querySelectorAll("#canvas")[0];
					let engine = contexts.engine = new BABYLON.Engine(canvas, true, {preserveDrawingBuffer: true, stencil: true});
					let scene  = contexts.scene = new BABYLON.Scene(engine);
					gear.init(contexts);
				})();

				// event handler
				window.addEventListener('resize', function() {
					contexts.engine.resize();
				});

				if(true) {
					contexts.engine.runRenderLoop(function() {
						gear.update(contexts);
						gear.render(contexts);
					});
				} else {
					let lastTime = new Date().getTime();
					let tick = function() {
						let t, d;
						gear.update(gear.scene);
						gear.render(gear.scene);
						t =  new Date().getTime();
						d = (1 / 10) - (t - lastTime);
						setTimeout(tick, Math.max(0, d));
						lastTime = t;
					};
					tick();
				}
			};

		</script> 
		<style type="text/css">
		<!--
			html, body {
				overflow: hidden;
				width   : 100%;
				height  : 100%;
				margin  : 0;
				padding : 0;
			}
			canvas#canvas {
				width:100%;
				height:100%;
			};
		-->
		</style> 
	</head>
	<body>
		<canvas id="canvas"></canvas>
	</body>
</html>
