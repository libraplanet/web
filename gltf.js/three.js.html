<!DOCTYPE html>
<html>
	<head>
		<meta name="viewport" content="width=device-width,initial-scale=1.0,maximum-scale=1.0,user-scalable=0" />
		<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
		<meta http-equiv="X-UA-Compatible" content="ie=edge">
		<title>three.js</title>
		<script src="three.js/three.min.js"></script> 
		<script src="three.js/OrbitControls.js"></script> 
		<script src="three.js/GLTFLoader.js"></script> 
		<script type="text/javascript">

			var Contexts = function() {
				var self = this;
				self.canvas = undefined;
				self.renderer = undefined;
				self.scene = undefined;
			};
			var Gear = function() {
				var self = this;
				/**
				 * member properties.
				 */
				self.cnt = 0;
				self.camera = undefined;;
				self.sceneMeshes = undefined;
				self.axesHelper = undefined;
				self.meshTextPlaneX = undefined;
				self.meshTextPlaneY = undefined;
				self.meshTextPlaneZ = undefined;

				self.modelQuaternion = undefined;

				/**
				 * Gear.init()
				 */
				self.init = function(contexts, width, height) {
					var scene = contexts.scene;
					var camera = self.camera;
					var modelQuaternion;


					// Quaternion;
					(function() {
						var qy = new THREE.Quaternion().setFromAxisAngle( new THREE.Vector3( 0, 1, 0 ), -(Math.PI / 4));
						var qx = new THREE.Quaternion().setFromAxisAngle( new THREE.Vector3( 1, 0, 0 ), (Math.PI / 4 / 2));
						modelQuaternion = self.modelQuaternion = new THREE.Quaternion().multiply(qx).multiply(qy);
					})();

					//camera
					(function() {
						var camera = self.camera = new THREE.PerspectiveCamera(50, width / height, 1, 100 );
						camera.position.set(0, 1, 7);
					})();
					//light
					(function() {
						(function() {
							var light = new THREE.AmbientLight(0xFFFFFF, 0.5);
							scene.add(light);
						})();
						(function() {

							var light = new THREE.DirectionalLight(0xFFFFFF, 0.75);
							light.position.set(0, 2, 7);
							light.castShadow = true;
							scene.add(light);
						})();
					})();
					//mesh
					(function() {
						var loader = new THREE.GLTFLoader();
						var path = './three.js/Duck.gltf';
						//var path = './three.js/BoomBox.glb';
						//var path = './three.js/Buggy.glb';
						loader.load(path, function(data){
							var sceneMeshes = self.sceneMeshes = data.scenes;
							Array.prototype.forEach.call(sceneMeshes, function(mesh) {
								scene.add(mesh);

								mesh.castShadow = true;
								mesh.rotation.set(0, 0, 0);
								mesh.applyQuaternion(modelQuaternion);
							});
						});
					})();

					//AxesHelper
					(function() {
						var axesHelper = self.axesHelper = new THREE.AxesHelper(1);
						scene.add(axesHelper);

						axesHelper.position.set(0,0,0);
						axesHelper.rotation.set(0,0,0);
						axesHelper.applyQuaternion(modelQuaternion);
						axesHelper.position.set(-3, -1 , -10);
					})();

					//grid
					(function() {
						const grid = new THREE.GridHelper(10, 10);
						scene.add(grid);
					})();
				};

				/**
				 * Gear.update
				 */
				self.update = function(contexts) {
				};

				/**
				 * Gear.render
				 */
				 self.render = function(contexts, gear) {
					var renderer = contexts.renderer;
					var scene = contexts.scene;
					var camera = self.camera;
					renderer.render(scene, camera);
				};
			};

			window.onload = function() {
				var contexts = new Contexts();
				var gear = new Gear();

				(function() {
					var width  = window.innerWidth;
					var height = window.innerHeight;
					var canvas = contexts.canvas = document.querySelectorAll("#canvas")[0];
					var renderer = contexts.renderer = new THREE.WebGLRenderer({
						canvas: canvas,
						antialias: true
					});
					var scene  = contexts.scene = new THREE.Scene();

					renderer.setSize(width, height);
					renderer.setClearColor(0xF0F0F0, 1.0);
					renderer.shadowMapEnabled = true;

					gear.init(contexts, width, height);
				})();

				// event handler
				(function() {
					// general
					(function() {
						window.addEventListener('resize', function(e) {
							var width  = window.innerWidth;
							var height = window.innerHeight;
							gear.camera.aspect = width / height;
							gear.camera.updateProjectionMatrix();
							contexts.renderer.setSize(width, height);
							console.log('resize(' + width + ', ' + height + ')')
						}, false);
					})();
					// canvas
					(function() {
						var canvas = contexts.canvas;
						canvas.addEventListener(null, function(e) {
						}, false);
						canvas.addEventListener('webglcontextlost', function(e) {
						}, false);
						canvas.addEventListener('webglcontextrestored', function(e) {
						}, false);
					})();
					// control
					(function() {
						var canvas = contexts.canvas;
						var rotModel = function(e) {
							if(gear.sceneMeshes && gear.modelQuaternion) {
								// https://developer.mozilla.org/ja/docs/Web/API/MouseEvent
								// https://threejs.org/docs/#api/en/scenes/Scene
								// https://threejs.org/docs/#api/en/core/Object3D
								// https://threejs.org/docs/#api/en/math/Matrix4
								// https://threejs.org/docs/#api/en/math/Quaternion
								// https://codeday.me/jp/qa/20190115/132954.html
								// https://codeday.me/jp/qa/20190227/332144.html
								// http://www.deqnotes.net/acmicpc/2d_geometry/using_vectors
								// http://gupuru.hatenablog.jp/entry/2013/11/27/214929
								var q;
								//calc
								(function() {
									var modelQuaternion = gear.modelQuaternion;
									var vx = e.movementX * 0.005;
									var vy = e.movementY * 0.005;
									var qx = new THREE.Quaternion().setFromAxisAngle( new THREE.Vector3( 1, 0, 0 ), vy);
									var qy = new THREE.Quaternion().setFromAxisAngle( new THREE.Vector3( 0, 1, 0 ), vx);
									var qz = new THREE.Quaternion().setFromAxisAngle( new THREE.Vector3( 0, 0, 0 ), 0);
									gear.modelQuaternion = q = new THREE.Quaternion().multiply(qx).multiply(qy).multiply(qz).multiply(modelQuaternion);
									console.log('e.movement(' + vx + ',' + vy + ')');
								})();
								//mesh
								(function() {
									var sceneMeshes = gear.sceneMeshes;
									Array.prototype.forEach.call(sceneMeshes, function(mesh) {
										//reset rotation
										mesh.rotation.set(0, 0, 0);
										mesh.applyQuaternion(q);
									});
								})();
								//axis helper
								(function() {
									var camera = gear.camera;
									var axesHelper = gear.axesHelper;
									var matCamR = gear.camera.matrix;
									var x = matCamR.elements[12];
									var y = matCamR.elements[13];
									var z = matCamR.elements[14];
									//matCamR.elements[12] = 0;
									//matCamR.elements[13] = 0;
									//matCamR.elements[14] = 0;

									axesHelper.position.set(0,0,0);
									axesHelper.rotation.set(0,0,0);
									axesHelper.applyQuaternion(q);
									axesHelper.position.set(-3, -1 , -10);
									//axesHelper.applyMatrix(matCamR);
								})();
							}
						}
						var cameraMoveDrag = function(e) {
							var vx = -(e.movementX * 0.01);
							var vy = (e.movementY * 0.01);
							var m = new THREE.Matrix4().makeTranslation(vx, vy, 0);
							gear.camera.applyMatrix(m);
						}
						var cameraMoveWheel = function(e) {
							// https://developer.mozilla.org/en-US/docs/Web/API/Element/wheel_event
							var v = event.deltaY * -0.01;
							var m = new THREE.Matrix4().makeTranslation(0, 0, v);
							gear.camera.applyMatrix(m);
						}
						var drop = function(e) {
							console.log('drop()!');
						}
						window.addEventListener(null, function(e) {
						}, false);
						window.addEventListener('contextmenu', function(e) {
							if(e.preventDefault){
								e.preventDefault();
							}else{
								return false;
							}
						}, false);
						canvas.addEventListener('mousedown', function(e) {
							console.log('event - mousedown!');
						}, false);
						canvas.addEventListener('mouseup', function(e) {
							console.log('event - mouseup!');
						}, false);
						canvas.addEventListener('mousemove', function(e) {
							console.log('event - mousemove!');
							// https://developer.mozilla.org/ja/docs/Web/API/MouseEvent
							// https://developer.mozilla.org/ja/docs/Web/API/MouseEvent/buttons
							if(e.buttons == 0x01) {
								rotModel(e);
							} else if(e.buttons == 0x04) {
								cameraMoveDrag(e);
							}
						}, false);
						canvas.addEventListener('dragenter', function(e) {
							console.log('event - dragenter!');
						}, false);
						canvas.addEventListener('dragover', function(e) {
							console.log('event - dragover!');
						}, false);
						canvas.addEventListener('drop', function(e) {
							console.log('event - drop!');
						}, false);
						canvas.addEventListener('wheel', function(e) {
							console.log('event - wheel!');
							cameraMoveWheel(e);
						}, false);
					})();
				})();

				//render
				(function() {
					var tick = function() {
						gear.update(contexts);
						gear.render(contexts);
						requestAnimationFrame(tick);
					};
					tick();
					//setInterval(tick, 1000/20);
				})();
			};

		</script> 
		<style type="text/css">
		<!--
			body {
				overscroll-behavior-y: none;
			}
			html, body {
				overflow: hidden;
				width   : 100%;
				height  : 100%;
				margin  : 0;
				padding : 0;
			}
			canvas#canvas {
				width:100%;
				height:100%;
			};
		-->
		</style> 
	</head>
	<body>
		<canvas id="canvas"></canvas>
	</body>
</html>
