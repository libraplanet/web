<!DOCTYPE html>
<html>
	<head>
		<meta name="viewport" content="width=device-width,initial-scale=1.0,maximum-scale=1.0,user-scalable=0" />
		<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
		<meta http-equiv="X-UA-Compatible" content="ie=edge">
		<title>three.js</title>
		<script src="three.js/three.min.js"></script> 
		<script src="three.js/OrbitControls.js"></script> 
		<script src="three.js/GLTFLoader.js"></script> 
		<script type="text/javascript">
			var Contexts = function() {
				var self = this;
				self.canvas = undefined;
				self.renderer = undefined;
				self.scene = undefined;
			};
			var Gear = function() {
				var self = this;
				/**
				 * member properties.
				 */
				self.camera = undefined;
				self.sceneMeshes = undefined
				self.meshTextPlaneX = undefined
				self.meshTextPlaneY = undefined
				self.meshTextPlaneZ = undefined

				/**
				 * init()
				 */
				self.init = function(contexts, width, height) {
					var scene = contexts.scene;
					var camera = self.camera;

					//camera
					(function() {
						var camera = self.camera = new THREE.PerspectiveCamera(50, width / height, 1, 100 );
						camera.position.set(0, 1, 5);
					})();
					//light
					(function() {
						var light = new THREE.AmbientLight(0xffffff, 1);
						scene.add(light);
					})();
					//mesh
					(function() {
						var loader = new THREE.GLTFLoader();
						var path = './three.js/Duck.gltf';
						//var path = './three.js/BoomBox.glb';
						//var path = './three.js/Buggy.glb';
						loader.load(path, function(data){
							var a = self.sceneMeshes = data.scenes;
							Array.prototype.forEach.call(a, function(glSceheMesh) {
								scene.add(glSceheMesh);
							});
						});
					})();

					//grid
					(function() {
						const grid = new THREE.GridHelper(10, 5);
						scene.add(grid);
					})();
				};

				/**
				 * update
				 */
				self.update = function(contexts) {
				};

				/**
				 * render
				 */
				 self.render = function(contexts) {
					var renderer = contexts.renderer;
					var scene = contexts.scene;
					var camera = self.camera;
					renderer.render(scene, camera);
				};
			};

			window.onload = function() {
				var contexts = new Contexts();
				var gear = new Gear();

				(function() {
					var width  = window.innerWidth;
					var height = window.innerHeight;
					var canvas = contexts.canvas = document.querySelectorAll("#canvas")[0];
					var renderer = contexts.renderer = new THREE.WebGLRenderer({
						canvas: canvas,
						antialias: true
					});
					var scene  = contexts.scene = new THREE.Scene();

					renderer.setSize(width, height);
					renderer.setClearColor(0xC0C0C0, 1.0);

					gear.init(contexts, width, height);
				})();

				// event handler
				(function() {
					// general
					(function() {
						window.addEventListener('resize', function(e) {
							var width  = window.innerWidth;
							var height = window.innerHeight;
							gear.camera.aspect = width / height;
							gear.camera.updateProjectionMatrix();
							contexts.renderer.setSize(width, height);
							console.log('resize(' + width + ', ' + height + ')')
						}, false);
					})();
					// canvas
					(function() {
						var canvas = contexts.canvas;
						canvas.addEventListener(null, function(e) {
						}, false);
						canvas.addEventListener('webglcontextlost', function(e) {
						}, false);
						canvas.addEventListener('webglcontextrestored', function(e) {
						}, false);
					})();
					// control
					(function() {
						var canvas = contexts.canvas;
						var drag = function(e) {
							// https://developer.mozilla.org/ja/docs/Web/API/MouseEvent
							// https://threejs.org/docs/#api/en/scenes/Scene
							// https://threejs.org/docs/index.html#api/en/math/Matrix4
							// https://codeday.me/jp/qa/20190115/132954.html
							// http://www.deqnotes.net/acmicpc/2d_geometry/using_vectors
							var sceneMeshes = gear.sceneMeshes;
							var vx = e.movementX;
							var vy = e.movementY;
							var vec = new THREE.Vector2(vx, vy);
							var nomVec = new THREE.Vector2(-vy, vx);
							var pow = vec.length();
							var matX = new THREE.Matrix4().makeRotationX(0);
							var matY = new THREE.Matrix4().makeRotationY(vx * 0.05);
							var matZ = new THREE.Matrix4().makeRotationZ(vy * 0.05);
							var matR = new THREE.Matrix4().multiply(matX).multiply(matY).multiply(matZ);
							//var matR = new THREE.Matrix4().makeRotationAxis (new THREE.Vector3(-vy, vx, 0), pow * 0.05);
							console.log('vec(' + vx + ',' + vy + ') => nom(' + nomVec.x + ',' + nomVec.y + ') pow(' + pow + ')');
							Array.prototype.forEach.call(sceneMeshes, function(mesh) {
								//mesh.matrix.multiply(matR);
								mesh.setRotationFromMatrix(mesh.matrix.multiply(matR));
								//mesh.setRotationFromMatrix(mesh.matrix.multiply(matY));
								//mesh.setRotationFromMatrix(mesh.matrix.multiply(matZ));
							});
						}
						var drop = function(e) {
							console.log('drop()!');
						}
						window.addEventListener(null, function(e) {
						}, false);
						window.addEventListener('contextmenu', function(e) {
							if(e.preventDefault){
								e.preventDefault();
							}else{
								return false;
							}
						}, false);
						canvas.addEventListener('mousedown', function(e) {
							console.log('event - mousedown!');
						}, false);
						canvas.addEventListener('mouseup', function(e) {
							console.log('event - mouseup!');
						}, false);
						canvas.addEventListener('mousemove', function(e) {
							console.log('event - mousemove!');
							drag(e);
						}, false);
						canvas.addEventListener('dragenter', function(e) {
							console.log('event - dragenter!');
						}, false);
						canvas.addEventListener('dragover', function(e) {
							console.log('event - dragover!');
						}, false);
						canvas.addEventListener('drop', function(e) {
							console.log('event - drop!');
						}, false);
					})();
				})();

				//render
				(function() {
					var tick = function() {
						gear.update(contexts);
						gear.render(contexts);
						requestAnimationFrame(tick);
					};
					tick();
				})();
			};

		</script> 
		<style type="text/css">
		<!--
			html, body {
				overflow: hidden;
				width   : 100%;
				height  : 100%;
				margin  : 0;
				padding : 0;
			}
			canvas#canvas {
				width:100%;
				height:100%;
			};
		-->
		</style> 
	</head>
	<body>
		<canvas id="canvas"></canvas>
	</body>
</html>
