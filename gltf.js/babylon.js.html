<!DOCTYPE html>
<html>
	<head>
		<meta name="viewport" content="width=device-width,initial-scale=1.0,maximum-scale=1.0,user-scalable=0" />
		<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
		<title>babylon.js</title>
		<script src="babylon.js/babylon.max.js"></script> 
		<!-- <script src="babylon.js/babylon.gui.js"></script> -->
		<script src="babylon.js/babylon.gui.min.js"></script> 
		<!-- <script src="babylon.js/babylon.glTFFileLoader.js"></script> -->
		<script src="babylon.js/babylon.glTFFileLoader.min.js"></script> 

		<!-- <script src="babylon.js/babylon.glTFFileLoader.js"></script> -->
		<script src="babylon.js/babylon.glTFFileLoader.min.js"></script> 
		<script type="text/javascript">
			var Contexts = function() {
				var self = this;
				self.canvas = undefined;
				self.engine = undefined;
				self.scene = undefined;
			};
			var Gear = function() {
				var self = this;
				/**
				 * member properties.
				 */
				self.camera = undefined;
				self.meshModels = undefined
				self.meshTextPlaneX = undefined
				self.meshTextPlaneY = undefined
				self.meshTextPlaneZ = undefined

				/**
				 * init()
				 */
				self.init = function(scene) {
					var defCameraTgt = new BABYLON.Vector3(0, 0, 0);
					var defCameraPos = new BABYLON.Vector3(8, 5, 8);
					scene.useRightHandedSystem = true;

					// camera
					(function() {
						//var camera = new BABYLON.UniversalCamera('camera', new BABYLON.Vector3(0, 5, -10), scene);
						//camera.setTarget(BABYLON.Vector3.Zero());
						// Parameters: alpha, beta, radius, target position, scene
						var camera = new BABYLON.ArcRotateCamera("camera", 0, 0, 1, defCameraTgt, scene);
						// Positions the camera overwriting alpha, beta, radius
						camera.setPosition(defCameraPos);
						camera.attachControl(canvas, true);
						camera.lowerRadiusLimit = 1;
						camera.upperRadiusLimit = 1000;
						camera.wheelDeltaPercentage = 0.01;
						camera.pinchdeltapercentage = 0.01;
						self.camera = camera;
					})();

					// light
					(function() {
						var light = new BABYLON.HemisphericLight('light', new BABYLON.Vector3(0, 1, 0), scene);
					})();

					//// sphere
					//(function() {
					//	var sphere = BABYLON.Mesh.CreateSphere('sphere1', 16, 2, scene, false, BABYLON.Mesh.FRONTSIDE);
					//	sphere.position.y = 1;
					//})();

					//// ground 
					//(function() {
					//	 var ground = BABYLON.Mesh.CreateGround('ground1', 6, 6, 2, scene, false);
					//})();

					// Append glTF model to scene.
					(function() {
						//var fname = './babylon.js/BoomBox.glb';
						//var fname = './babylon.js/Buggy.glb';
						var fname = './babylon.js/Duck.gltf';
						//BABYLON.SceneLoader.Append('./babylon.js/', 'BoomBox.glb', scene, function (scene) {
						BABYLON.SceneLoader.ImportMesh('', fname, null, scene, function (meshes) {
							self.meshModels = meshes;
						});
					})();

					//lines
					(function() {
						var drawLine = function (name, points, color) {
							var meshLine = BABYLON.Mesh.CreateLines(name, points, scene, true);
							meshLine.color = color;
						};
						var color = new BABYLON.Color3(0.4, 0.4, 0.4);
						var len = 10;

						// Y面
						for(var i = 0; i < 10; i++) {
							v = i + 1;
							//X軸
							drawLine('line', [new BABYLON.Vector3(len, 0,    v), new BABYLON.Vector3(-len, 0,    v)], color);
							drawLine('line', [new BABYLON.Vector3(len, 0,   -v), new BABYLON.Vector3(-len, 0,   -v)], color);
							//Z軸
							drawLine('line', [new BABYLON.Vector3(  v, 0,  len), new BABYLON.Vector3(   v, 0, -len)], color);
							drawLine('line', [new BABYLON.Vector3( -v, 0,  len), new BABYLON.Vector3(  -v, 0, -len)], color);
						}

						//中心軸
						(function() {
							var createTextPlaneMesh = function(text, color, size) {
								var dynamicTexture, plane;
								var dynamicTexture = new BABYLON.DynamicTexture('DynamicTexture', 50, scene, true);
								dynamicTexture.hasAlpha = true;
								dynamicTexture.drawText(text, 5, 40, 'bold 36px Arial', color , 'transparent', true);
								plane = new BABYLON.Mesh.CreatePlane('TextPlane', size, scene, true);
								plane.material = new BABYLON.StandardMaterial('TextPlaneMaterial', scene);
								plane.material.backFaceCulling = false;
								plane.material.specularColor = new BABYLON.Color3(0, 0, 0);
								plane.material.diffuseTexture = dynamicTexture;
								return plane;
							};
							drawLine('line', [new BABYLON.Vector3(0, 0, 0), new BABYLON.Vector3( len,    0,    0)], new BABYLON.Color3(  1, 0.2, 0.2));
							drawLine('line', [new BABYLON.Vector3(0, 0, 0), new BABYLON.Vector3(   0,  len,    0)], new BABYLON.Color3(0.2,   1, 0.2));
							drawLine('line', [new BABYLON.Vector3(0, 0, 0), new BABYLON.Vector3(   0,    0,  len)], new BABYLON.Color3(0.2, 0.2,   1));
							drawLine('line', [new BABYLON.Vector3(0, 0, 0), new BABYLON.Vector3(-len,    0,    0)], color);
							drawLine('line', [new BABYLON.Vector3(0, 0, 0), new BABYLON.Vector3(   0, -len,    0)], color);
							drawLine('line', [new BABYLON.Vector3(0, 0, 0), new BABYLON.Vector3(   0,    0, -len)], color);

							self.meshTextPlaneX = createTextPlaneMesh('X', '#FF3333', 1.0);
							self.meshTextPlaneY = createTextPlaneMesh('Y', '#33FF33', 1.0);
							self.meshTextPlaneZ = createTextPlaneMesh('Z', '#3333FF', 1.0);
							self.meshTextPlaneX.position = new BABYLON.Vector3( len,    0,    0);
							self.meshTextPlaneY.position = new BABYLON.Vector3(   0,  len,    0);
							self.meshTextPlaneZ.position = new BABYLON.Vector3(   0,    0,  len);
						})();
					})();


					// helper
					(function() {
						var helper = scene.createDefaultEnvironment();
						helper.setMainColor(new BABYLON.Color3(0.75, 0.75, 0.75));
					})();

					// option
					(function() {
						var optimizer, options;
						options = new BABYLON.SceneOptimizerOptions();
						options .targetFrameRate = 20;
						optimizer = new BABYLON.SceneOptimizer(scene, options);
					})();

					// ui
					(function() {
						var advancedTexture = BABYLON.GUI.AdvancedDynamicTexture.CreateFullscreenUI("UI");
						var panel = new BABYLON.GUI.StackPanel();
						var resetCamera = function() {
							camera.setTarget(defCameraTgt);
							camera.setPosition(defCameraPos);
						};
						var reloadModel = function(url) {
							if(self.meshModels) {
								Array.prototype.forEach.call(self.meshModels, function(mesh) {
									scene.removeMesh(mesh);
								});
								self.meshModels = undefined;
							}
							BABYLON.SceneLoader.ImportMesh('', url, null, scene, function (meshes) {
								//resetCamera();
								self.meshModels = meshes;
							});
						};
						(function() {
							panel.width = "220px";
							panel.fontSize = "12px";
							panel.horizontalAlignment = BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_RIGHT;
							panel.verticalAlignment = BABYLON.GUI.Control.VERTICAL_ALIGNMENT_BOTTOM;
						})();
						(function() {
							var button = BABYLON.GUI.Button.CreateSimpleButton("button1", "camera reset");
							button.paddingTop = "5px";
							button.paddingBottom = "5px";
							button.width = "160px";
							button.height = "35px";
							button.color = "white";
							button.background = "blue";
							button.onPointerDownObservable.add(function(){
								resetCamera();
							});
							panel.addControl(button);
						})();
						(function() {
							var button = BABYLON.GUI.Button.CreateSimpleButton("button2", "(NG) model BoomBox.glb");
							button.paddingTop = "5px";
							button.paddingBottom = "5px";
							button.width = "160px";
							button.height = "35px";
							button.color = "white";
							button.background = "red";
							button.onPointerDownObservable.add(function(){
								reloadModel('./babylon.js/BoomBox.glb');
							});
							panel.addControl(button);
						})();
						(function() {
							var button = BABYLON.GUI.Button.CreateSimpleButton("button3", "(NG) model Buggy.glb");
							button.paddingTop = "5px";
							button.paddingBottom = "5px";
							button.width = "160px";
							button.height = "35px";
							button.color = "white";
							button.background = "red";
							button.onPointerDownObservable.add(function(){
								reloadModel('./babylon.js/Buggy.glb');
							});
							panel.addControl(button);
						})();
						(function() {
							var button = BABYLON.GUI.Button.CreateSimpleButton("button4", "(NG) model Duck.glt");
							button.paddingTop = "5px";
							button.paddingBottom = "5px";
							button.width = "160px";
							button.height = "35px";
							button.color = "white";
							button.background = "red";
							button.onPointerDownObservable.add(function(){
								reloadModel('./babylon.js/Duck.gltf');
							});
							panel.addControl(button);
						})();
						advancedTexture.addControl(panel);
					})();

				};

				/**
				 * update
				 */
				self.update = function(scene) {
					// Animations
					(function() {
						//billbording
						(function() {
							//var camMat = camera.getViewMatrix();
							var camMat = self.camera.getWorldMatrix();
							if(camMat) {
								var iMat = BABYLON.Matrix.Identity();
								var revMat = camMat.multiply(iMat);
								var revQuat = BABYLON.Quaternion.FromRotationMatrix(revMat);
								self.meshTextPlaneX.rotationQuaternion = revQuat;
								self.meshTextPlaneY.rotationQuaternion = revQuat;
								self.meshTextPlaneZ.rotationQuaternion = revQuat;
							}
						})();
					})();
				};

				/**
				 * render
				 */
				self.render = function(scene) {
					scene.render();
				};
			};
			var contexts = new Contexts();
			var gear = new Gear();

			window.onload = function() {
				var canvas = contexts.canvas = document.querySelectorAll("#canvas")[0];
				var engine = contexts.engine = new BABYLON.Engine(canvas, true, {preserveDrawingBuffer: true, stencil: true});
				var scene  = contexts.scene = new BABYLON.Scene(engine);
				gear.init(scene);
				engine.runRenderLoop(function() {
					gear.update(scene);
					gear.render(scene);
				});
				// event handler
				window.addEventListener('resize', function() {
					engine.resize();
				});
			};

		</script> 
		<style type="text/css">
		<!--
			html, body {
				overflow: hidden;
				width   : 100%;
				height  : 100%;
				margin  : 0;
				padding : 0;
			}
			canvas#canvas {
				width:100%;
				height:100%;
			};
		-->
		</style> 
	</head>
	<body>
		<canvas id="canvas"></canvas>
	</body>
</html>
